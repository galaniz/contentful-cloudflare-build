{"ast":null,"code":"import _defineProperty from \"/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport L, { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport { useId, mergeRefs } from '@contentful/f36-core';\nimport { usePopper } from 'react-popper';\nimport { cx, css } from 'emotion';\nimport { Portal } from '@contentful/f36-utils';\nimport x from '@contentful/f36-tokens';\nvar te = Object.defineProperty,\n  re = Object.defineProperties;\nvar ne = Object.getOwnPropertyDescriptors;\nvar y = Object.getOwnPropertySymbols;\nvar k = Object.prototype.hasOwnProperty,\n  A = Object.prototype.propertyIsEnumerable;\nvar F = function F(e, t, o) {\n    return t in e ? te(e, t, {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: o\n    }) : e[t] = o;\n  },\n  a = function a(e, t) {\n    for (var o in t || (t = {})) k.call(t, o) && F(e, o, t[o]);\n    if (y) {\n      var _iterator = _createForOfIteratorHelper(y(t)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var o = _step.value;\n          A.call(t, o) && F(e, o, t[o]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return e;\n  },\n  m = function m(e, t) {\n    return re(e, ne(t));\n  };\nvar N = function N(e, t) {\n  var o = {};\n  for (var r in e) k.call(e, r) && t.indexOf(r) < 0 && (o[r] = e[r]);\n  if (e != null && y) {\n    var _iterator2 = _createForOfIteratorHelper(y(e)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var r = _step2.value;\n        t.indexOf(r) < 0 && A.call(e, r) && (o[r] = e[r]);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return o;\n};\nvar K = function K(e, t, o) {\n  return new Promise(function (r, f) {\n    var v = function v(s) {\n        try {\n          l(o.next(s));\n        } catch (n) {\n          f(n);\n        }\n      },\n      P = function P(s) {\n        try {\n          l(o.throw(s));\n        } catch (n) {\n          f(n);\n        }\n      },\n      l = function l(s) {\n        return s.done ? r(s.value) : Promise.resolve(s.value).then(v, P);\n      };\n    l((o = o.apply(e, t)).next());\n  });\n};\nvar U = L.createContext(void 0),\n  h = function h() {\n    var e = L.useContext(U);\n    if (e === void 0) throw new Error(\"usePopoverContext must be used within a PopoverContextProvider\");\n    return e;\n  },\n  $ = U.Provider;\nfunction V(e) {\n  var _this = this;\n  var t = e.children,\n    o = e.isOpen,\n    _e$placement = e.placement,\n    r = _e$placement === void 0 ? \"bottom-start\" : _e$placement,\n    _e$isFullWidth = e.isFullWidth,\n    f = _e$isFullWidth === void 0 ? !1 : _e$isFullWidth,\n    _e$isAutoalignmentEna = e.isAutoalignmentEnabled,\n    v = _e$isAutoalignmentEna === void 0 ? !0 : _e$isAutoalignmentEna,\n    _e$usePortal = e.usePortal,\n    P = _e$usePortal === void 0 ? !0 : _e$usePortal,\n    _e$closeOnBlur = e.closeOnBlur,\n    l = _e$closeOnBlur === void 0 ? !0 : _e$closeOnBlur,\n    _e$closeOnEsc = e.closeOnEsc,\n    s = _e$closeOnEsc === void 0 ? !0 : _e$closeOnEsc,\n    n = e.onClose,\n    _e$autoFocus = e.autoFocus,\n    C = _e$autoFocus === void 0 ? !0 : _e$autoFocus,\n    E = e.id,\n    _e$offset = e.offset,\n    T = _e$offset === void 0 ? [1, 4] : _e$offset,\n    _e$renderOnlyWhenOpen = e.renderOnlyWhenOpen,\n    g = _e$renderOnlyWhenOpen === void 0 ? !0 : _e$renderOnlyWhenOpen,\n    _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    i = _useState2[0],\n    X = _useState2[1],\n    _useState3 = useState(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    c = _useState4[0],\n    Y = _useState4[1],\n    _usePopper = usePopper(i, c, {\n      placement: r,\n      modifiers: [{\n        name: \"offset\",\n        options: {\n          offset: T\n        }\n      }, m(a({}, ue), {\n        enabled: f\n      }), {\n        name: \"preventOverflow\",\n        enabled: v,\n        options: {\n          mainAxis: !0\n        }\n      }, {\n        name: \"flip\",\n        enabled: v\n      }]\n    }),\n    S = _usePopper.attributes,\n    M = _usePopper.update,\n    I = _usePopper.styles;\n  useEffect(function () {\n    o && C && c && c.focus({\n      preventScroll: !0\n    });\n  }, [o, c]), useEffect(function () {\n    (function () {\n      return K(_this, null, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.t0 = o && M;\n              if (!_context.t0) {\n                _context.next = 4;\n                break;\n              }\n              _context.next = 4;\n              return M();\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n    })();\n  }, [o, M]);\n  var Z = useId(void 0, \"popover-content\"),\n    w = E || Z,\n    B = useCallback(function () {\n      n == null || n(), setTimeout(function () {\n        return i == null ? void 0 : i.focus({\n          preventScroll: !0\n        });\n      }, 0);\n    }, [n, i]),\n    O = useRef(!1),\n    _ = useMemo(function () {\n      return {\n        isOpen: Boolean(o),\n        usePortal: P,\n        renderOnlyWhenOpen: g,\n        getTriggerProps: function getTriggerProps() {\n          var _ref;\n          var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var H = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          return _ref = {\n            onMouseDown: function onMouseDown(u) {\n              var d;\n              O.current = !0, (d = p.onMouseDown) == null || d.call(p, u);\n            },\n            onMouseUp: function onMouseUp(u) {\n              var d;\n              O.current = !1, (d = p.onMouseUp) == null || d.call(p, u);\n            },\n            ref: mergeRefs(X, H)\n          }, _defineProperty(_ref, \"aria-expanded\", Boolean(o)), _defineProperty(_ref, \"aria-controls\", w), _ref;\n        },\n        getPopoverProps: function getPopoverProps() {\n          var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var H = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          return m(a({}, S.popper), {\n            style: a(a({}, p.style || {}), I.popper),\n            ref: mergeRefs(Y, H),\n            id: w,\n            onBlur: function onBlur(u) {\n              if (p.onBlur && p.onBlur(u), !l) return;\n              var d = document.activeElement,\n                b = u.relatedTarget || d,\n                ee = c === b || (c == null ? void 0 : c.contains(b)),\n                oe = i === b || (i == null ? void 0 : i.contains(b)) || O.current;\n              ee || oe || n == null || n();\n            },\n            onKeyDown: function onKeyDown(u) {\n              p.onKeyDown && p.onKeyDown(u), s && u.key === \"Escape\" && B();\n            }\n          });\n        }\n      };\n    }, [o, g, S, I, P, w, s, l, c, i, B, n]);\n  return L.createElement($, {\n    value: _\n  }, t);\n}\nvar ue = {\n  name: \"sameWidth\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  requires: [\"computeStyles\"],\n  fn: function fn(_ref2) {\n    var e = _ref2.state;\n    e.styles.popper.width = \"\".concat(e.rects.reference.width, \"px\");\n  },\n  effect: function effect(_ref3) {\n    var e = _ref3.state;\n    return function () {\n      var t = e.elements.reference;\n      e.elements.popper.style.width = \"\".concat(t.offsetWidth, \"px\");\n    };\n  }\n};\nvar J = function J(e) {\n  return {\n    container: css({\n      display: e ? \"initial\" : \"none\",\n      background: x.colorWhite,\n      border: 0,\n      borderRadius: x.borderRadiusMedium,\n      boxShadow: x.boxShadowDefault,\n      zIndex: x.zIndexDropdown,\n      \"&:focus\": {\n        boxShadow: x.glowPrimary,\n        outline: \"none\"\n      },\n      \"&:focus:not(:focus-visible)\": {\n        boxShadow: x.boxShadowDefault\n      }\n    })\n  };\n};\nvar fe = function fe(e, t) {\n    var g = e,\n      o = g.children,\n      r = g.className,\n      _g$testId = g.testId,\n      f = _g$testId === void 0 ? \"cf-ui-popover-content\" : _g$testId,\n      _g$role = g.role,\n      v = _g$role === void 0 ? \"dialog\" : _g$role,\n      P = N(g, [\"children\", \"className\", \"testId\", \"role\"]),\n      _h = h(),\n      l = _h.isOpen,\n      s = _h.renderOnlyWhenOpen,\n      n = _h.getPopoverProps,\n      C = _h.usePortal,\n      E = J(l),\n      T = L.createElement(\"div\", m(a(a({}, P), n(P, t)), {\n        className: cx(E.container, r),\n        \"data-test-id\": f,\n        tabIndex: -1,\n        role: v,\n        \"data-position-absolute\": !0\n      }), o);\n    return s && !l ? null : C ? L.createElement(Portal, null, T) : T;\n  },\n  R = L.forwardRef(fe);\nvar D = function D(e) {\n  var r;\n  var t = L.Children.only(e.children),\n    _h2 = h(),\n    o = _h2.getTriggerProps;\n  return L.cloneElement(t, m(a({}, o(t.props, t.ref)), {\n    \"aria-haspopup\": (r = t.props[\"aria-haspopup\"]) != null ? r : \"dialog\"\n  }));\n};\nvar W = V;\nW.Content = R;\nW.Trigger = D;\nexport { W as Popover, R as PopoverContent, D as PopoverTrigger };","map":{"version":3,"names":[],"sources":["/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-popover/src/Popover.tsx","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-popover/src/PopoverContext.ts","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-popover/src/PopoverContent/PopoverContent.tsx","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-popover/src/PopoverContent/PopoverContent.styles.ts","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-popover/src/PopoverTrigger/PopoverTrigger.tsx","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-popover/src/CompoundPopover.tsx"],"sourcesContent":["import React, {\n  useMemo,\n  useState,\n  useEffect,\n  useCallback,\n  useRef,\n} from 'react';\nimport { useId, mergeRefs, type ExpandProps } from '@contentful/f36-core';\nimport type { Placement, Modifier } from '@popperjs/core';\nimport { PopoverContextProvider, PopoverContextType } from './PopoverContext';\nimport { usePopper } from 'react-popper';\n\nexport interface PopoverProps {\n  children: React.ReactNode;\n\n  /**\n   * Boolean to determine if the Popover should be the same width as\n   * the trigger element\n   *\n   * @default false\n   */\n  isFullWidth?: boolean;\n\n  /**\n   * Boolean to control whether or not the Popover is open\n   *\n   * @default false\n   */\n  isOpen?: boolean;\n\n  /**\n   * Callback fired when the popover closes\n   */\n  onClose?: () => void;\n\n  /**\n   * Determines the preferred position of the Popover. This position is not\n   * guaranteed, as the Popover might be moved to fit the viewport\n   *\n   * @default bottom-start\n   */\n  placement?: Placement;\n\n  /**\n   * Boolean to control if popover is allowed to change its placement automatically\n   * based on available space in the viewport.\n   *\n   * For example:\n   * If you set placement prop to bottom, but there isn't enough space to position the popover in that direction,\n   * it will change the popper placement to top. As soon as enough space is detected, the placement will be reverted to the defined one.\n   *\n   * If you want the popover to strictly follow the placement prop you should set this prop to false.\n   *\n   * @default true\n   */\n  isAutoalignmentEnabled?: boolean;\n\n  /**\n   * Boolean to control whether or not to render the Popover in a React Portal.\n   * Rendering content inside a Portal allows the Popover to escape the bounds\n   * of its parent while still being positioned correctly. Using a Portal is\n   * necessary if an ancestor of the Popover hides overflow.\n   *\n   * @default true\n   */\n  usePortal?: boolean;\n\n  /**\n   * If true, the popover will close when you blur out it by clicking outside or tabbing out\n   *\n   * @default true\n   */\n  closeOnBlur?: boolean;\n\n  /**\n   * If true, the popover will close when you hit the Esc key\n   *\n   * @default true\n   */\n  closeOnEsc?: boolean;\n\n  /**\n   * If true, the popover will be focused after opening\n   *\n   * @default true\n   */\n  autoFocus?: boolean;\n\n  /**\n   * Popover id. Will be used as an `id` attribute on popover\n   * and as `aria-controls` attribute on trigger\n   *\n   * @default true\n   */\n  id?: string;\n\n  /**\n   * The `X-axis` and `Y-axis` offset to position popper element\n   * from its trigger element. `[X, Y]`\n   *\n   * @default [1, 4]\n   */\n  offset?: [number, number];\n\n  /**\n   * Defines if popover should be rendered in the DOM only when it's open\n   * or all the time (after the component has been mounted)\n   *\n   * @default true\n   */\n  renderOnlyWhenOpen?: boolean;\n}\n\nexport function Popover(props: ExpandProps<PopoverProps>) {\n  const {\n    children,\n    isOpen,\n    placement = 'bottom-start',\n    isFullWidth = false,\n    isAutoalignmentEnabled = true,\n    usePortal = true,\n    closeOnBlur = true,\n    closeOnEsc = true,\n    onClose,\n    autoFocus = true,\n    id,\n    offset = [1, 4],\n    renderOnlyWhenOpen = true,\n  } = props;\n\n  const [triggerElement, setTriggerElement] = useState<HTMLElement | null>(\n    null,\n  );\n  const [popoverElement, setPopoverElement] = useState<HTMLElement | null>(\n    null,\n  );\n\n  const {\n    attributes: popperAttributes,\n    update,\n    styles: popperStyles,\n  } = usePopper(triggerElement, popoverElement, {\n    placement,\n    modifiers: [\n      {\n        name: 'offset',\n        options: {\n          offset,\n        },\n      },\n      {\n        ...sameWidth,\n        enabled: isFullWidth,\n      },\n      {\n        name: 'preventOverflow',\n        enabled: isAutoalignmentEnabled,\n        options: {\n          mainAxis: true,\n        },\n      },\n      {\n        name: 'flip',\n        enabled: isAutoalignmentEnabled,\n      },\n    ],\n  });\n\n  useEffect(() => {\n    if (isOpen && autoFocus && popoverElement) {\n      popoverElement.focus({ preventScroll: true });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, popoverElement]);\n\n  useEffect(() => {\n    const updatePosition = async () => {\n      if (isOpen && update) {\n        await update();\n      }\n    };\n    updatePosition();\n  }, [isOpen, update]);\n\n  const popoverGeneratedId = useId(undefined, 'popover-content');\n  const popoverId = id || popoverGeneratedId;\n\n  const closeAndFocusTrigger = useCallback(() => {\n    onClose?.();\n\n    // setTimeout trick to make it work with focus-lock\n    setTimeout(() => triggerElement?.focus({ preventScroll: true }), 0);\n  }, [onClose, triggerElement]);\n\n  // Safari has an issue with the relatedTarget that we use on the onBlur for getPopoverProps,\n  // which was causing the popover to close and reopen when clicking on the trigger.\n  // We will use the isMouseDown to prevent triggering blur in the cases where the user clicks on the trigger.\n  const isMouseDown = useRef<Boolean>(false);\n\n  const contextValue: PopoverContextType = useMemo(\n    () => ({\n      isOpen: Boolean(isOpen),\n      usePortal,\n      renderOnlyWhenOpen,\n      getTriggerProps: (_props = {}, _ref = null) => ({\n        onMouseDown: (event) => {\n          isMouseDown.current = true;\n          _props.onMouseDown?.(event);\n        },\n        onMouseUp: (event) => {\n          isMouseDown.current = false;\n          _props.onMouseUp?.(event);\n        },\n        ref: mergeRefs(setTriggerElement, _ref),\n        ['aria-expanded']: Boolean(isOpen),\n        ['aria-controls']: popoverId,\n      }),\n      getPopoverProps: (_props = {}, _ref = null) => ({\n        ...popperAttributes.popper,\n        style: {\n          ...(_props.style || {}),\n          ...popperStyles.popper,\n        },\n        ref: mergeRefs(setPopoverElement, _ref),\n        id: popoverId,\n        onBlur: (event: React.FocusEvent<HTMLDivElement>) => {\n          if (_props.onBlur) {\n            _props.onBlur(event);\n          }\n\n          if (!closeOnBlur) {\n            return;\n          }\n\n          const activeElement = document.activeElement;\n          const relatedTarget = event.relatedTarget || activeElement;\n\n          const targetIsPopover =\n            popoverElement === relatedTarget ||\n            popoverElement?.contains(relatedTarget);\n          const targetIsTrigger =\n            triggerElement === relatedTarget ||\n            triggerElement?.contains(relatedTarget) ||\n            isMouseDown.current;\n\n          if (targetIsPopover || targetIsTrigger) {\n            return;\n          }\n\n          onClose?.();\n        },\n        onKeyDown: (event: React.KeyboardEvent<HTMLDivElement>) => {\n          if (_props.onKeyDown) {\n            _props.onKeyDown(event);\n          }\n\n          if (closeOnEsc && event.key === 'Escape') {\n            closeAndFocusTrigger();\n          }\n        },\n      }),\n    }),\n    [\n      isOpen,\n      renderOnlyWhenOpen,\n      popperAttributes,\n      popperStyles,\n      usePortal,\n      popoverId,\n      closeOnEsc,\n      closeOnBlur,\n      popoverElement,\n      triggerElement,\n      closeAndFocusTrigger,\n      onClose,\n    ],\n  );\n\n  return (\n    <PopoverContextProvider value={contextValue}>\n      {children}\n    </PopoverContextProvider>\n  );\n}\n\n/**\n * Sets the popover width to the size of the trigger element.\n */\nconst sameWidth: Modifier<'sameWidth', any> = {\n  name: 'sameWidth',\n  enabled: true,\n  phase: 'beforeWrite',\n  requires: ['computeStyles'],\n  fn: ({ state }) => {\n    state.styles.popper.width = `${state.rects.reference.width}px`;\n  },\n  effect:\n    ({ state }) =>\n    () => {\n      const reference = state.elements.reference as HTMLElement;\n      state.elements.popper.style.width = `${reference.offsetWidth}px`;\n    },\n};\n","import React, { HTMLProps } from 'react';\n\nexport type PopoverContextType = {\n  isOpen: boolean;\n  usePortal: boolean;\n  renderOnlyWhenOpen: boolean;\n  getPopoverProps: (\n    _props: HTMLProps<HTMLDivElement>,\n    _ref: React.Ref<HTMLDivElement>,\n  ) => HTMLProps<HTMLDivElement>;\n  getTriggerProps: (\n    _props: HTMLProps<HTMLElement>,\n    _ref: React.Ref<HTMLElement>,\n  ) => HTMLProps<HTMLElement>;\n};\n\nconst PopoverContext = React.createContext<PopoverContextType | undefined>(\n  undefined,\n);\n\nexport const usePopoverContext = () => {\n  const context = React.useContext(PopoverContext);\n\n  if (context === undefined) {\n    throw new Error(\n      'usePopoverContext must be used within a PopoverContextProvider',\n    );\n  }\n\n  return context;\n};\n\nexport const PopoverContextProvider = PopoverContext.Provider;\n","import React from 'react';\nimport { cx } from 'emotion';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\nimport { usePopoverContext } from '../PopoverContext';\nimport { Portal } from '@contentful/f36-utils';\nimport { getPopoverContentStyles } from './PopoverContent.styles';\n\ninterface PopoverContentInternalProps extends CommonProps {\n  children?: React.ReactNode;\n}\n\nexport type PopoverContentProps = PropsWithHTMLElement<\n  PopoverContentInternalProps,\n  'div'\n>;\n\nconst _PopoverContent = (props: ExpandProps<PopoverContentProps>, ref) => {\n  const {\n    children,\n    className,\n    testId = 'cf-ui-popover-content',\n    role = 'dialog',\n    ...otherProps\n  } = props;\n  const { isOpen, renderOnlyWhenOpen, getPopoverProps, usePortal } =\n    usePopoverContext();\n\n  const styles = getPopoverContentStyles(isOpen);\n\n  const content = (\n    <div\n      {...otherProps}\n      {...getPopoverProps(otherProps, ref)}\n      className={cx(styles.container, className)}\n      data-test-id={testId}\n      tabIndex={-1}\n      role={role}\n      // specific attribute to mark that this element is absolute positioned\n      // for internal contentful apps usage\n      data-position-absolute\n    >\n      {children}\n    </div>\n  );\n\n  if (renderOnlyWhenOpen && !isOpen) {\n    return null;\n  }\n\n  return usePortal ? <Portal>{content}</Portal> : content;\n};\n\nexport const PopoverContent = React.forwardRef(_PopoverContent);\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getPopoverContentStyles = (isOpen: boolean) => ({\n  container: css({\n    display: isOpen ? 'initial' : 'none',\n    background: tokens.colorWhite,\n    border: 0,\n    borderRadius: tokens.borderRadiusMedium,\n    boxShadow: tokens.boxShadowDefault,\n    zIndex: tokens.zIndexDropdown,\n    '&:focus': {\n      boxShadow: tokens.glowPrimary,\n      outline: 'none',\n    },\n    '&:focus:not(:focus-visible)': {\n      boxShadow: tokens.boxShadowDefault,\n    },\n  }),\n});\n","import React from 'react';\nimport { usePopoverContext } from '../PopoverContext';\n\nexport interface PopoverTriggerProps {\n  children: React.ReactNode;\n}\n\n/**\n * PopoverTrigger opens the popover. It must be an interactive element.\n */\nexport const PopoverTrigger = (props: PopoverTriggerProps) => {\n  const child = React.Children.only(props.children) as any;\n  const { getTriggerProps } = usePopoverContext();\n\n  return React.cloneElement(child, {\n    ...getTriggerProps(child.props, child.ref),\n    'aria-haspopup': child.props['aria-haspopup'] ?? 'dialog',\n  });\n};\n","import { Popover as OriginalPopover } from './Popover';\nimport { PopoverContent } from './PopoverContent/PopoverContent';\nimport { PopoverTrigger } from './PopoverTrigger/PopoverTrigger';\n\ntype CompoundPopover = typeof OriginalPopover & {\n  Content: typeof PopoverContent;\n  Trigger: typeof PopoverTrigger;\n};\n\nexport const Popover = OriginalPopover as CompoundPopover;\nPopover.Content = PopoverContent;\nPopover.Trigger = PopoverTrigger;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}