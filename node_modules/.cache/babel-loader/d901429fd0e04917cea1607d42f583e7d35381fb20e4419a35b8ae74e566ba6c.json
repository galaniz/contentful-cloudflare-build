{"ast":null,"code":"import { cx, css } from 'emotion';\nimport P, { createContext, forwardRef, useContext, useState, useMemo, Children, isValidElement } from 'react';\nimport { Box } from '@contentful/f36-core';\nimport a from '@contentful/f36-tokens';\nimport { Caption, Text } from '@contentful/f36-typography';\nimport { SortIcon, SortAscendingIcon, SortDescendingIcon } from '@contentful/f36-icons';\nvar se = Object.defineProperty,\n  pe = Object.defineProperties;\nvar ie = Object.getOwnPropertyDescriptors;\nvar C = Object.getOwnPropertySymbols;\nvar $ = Object.prototype.hasOwnProperty,\n  O = Object.prototype.propertyIsEnumerable;\nvar W = (e, t, o) => t in e ? se(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: o\n  }) : e[t] = o,\n  n = (e, t) => {\n    for (var o in t || (t = {})) $.call(t, o) && W(e, o, t[o]);\n    if (C) for (var o of C(t)) O.call(t, o) && W(e, o, t[o]);\n    return e;\n  },\n  s = (e, t) => pe(e, ie(t));\nvar d = (e, t) => {\n  var o = {};\n  for (var r in e) $.call(e, r) && t.indexOf(r) < 0 && (o[r] = e[r]);\n  if (e != null && C) for (var r of C(e)) t.indexOf(r) < 0 && O.call(e, r) && (o[r] = e[r]);\n  return o;\n};\nvar z = () => ({\n  inline: css({\n    borderRadius: a.borderRadiusMedium,\n    boxShadow: `0 0 0 1px ${a.gray200}`,\n    \"th:first-child\": {\n      borderTopLeftRadius: a.borderRadiusMedium\n    },\n    \"th:last-child\": {\n      borderTopRightRadius: a.borderRadiusMedium\n    },\n    \"tr:last-child td:first-child\": {\n      borderBottomLeftRadius: a.borderRadiusMedium\n    },\n    \"tr:last-child td:last-child\": {\n      borderBottomRightRadius: a.borderRadiusMedium\n    }\n  }),\n  embedded: css({\n    borderBottom: `1px solid ${a.gray200}`\n  }),\n  root: css({\n    width: \"100%\"\n  })\n});\nvar F = createContext({}),\n  K = () => useContext(F),\n  G = F.Provider;\nvar E = forwardRef((T, i) => {\n  var m = T,\n    {\n      children: e,\n      className: t,\n      layout: o = \"inline\",\n      testId: r = \"cf-ui-table\",\n      verticalAlign: l = \"top\"\n    } = m,\n    p = d(m, [\"children\", \"className\", \"layout\", \"testId\", \"verticalAlign\"]);\n  let b = z();\n  return P.createElement(Box, s(n({\n    cellPadding: \"0\",\n    cellSpacing: \"0\"\n  }, p), {\n    as: \"table\",\n    display: \"table\",\n    ref: i,\n    className: cx(b.root, b[o], t),\n    testId: r\n  }), P.createElement(G, {\n    value: {\n      verticalAlign: l\n    }\n  }, e));\n});\nE.displayName = \"Table\";\nfunction V(p, l) {\n  var i = p,\n    {\n      className: e,\n      children: t,\n      testId: o = \"cf-ui-table-body\"\n    } = i,\n    r = d(i, [\"className\", \"children\", \"testId\"]);\n  return P.createElement(Box, s(n({}, r), {\n    as: \"tbody\",\n    className: e,\n    ref: l,\n    testId: o\n  }), t);\n}\nV.displayName = \"TableBody\";\nvar H = forwardRef(V);\nvar u = {\n    body: {\n      name: \"body\",\n      as: \"td\",\n      offsetTop: 0\n    },\n    head: {\n      name: \"head\",\n      as: \"th\",\n      offsetTop: 0\n    }\n  },\n  I = createContext(u.body),\n  M = () => useContext(I),\n  v = I.Provider;\nvar _ = _ref => {\n  let {\n    align: e,\n    isSortable: t,\n    isTableHead: o,\n    sortDirection: r,\n    verticalAlign: l\n  } = _ref;\n  return {\n    button: css({\n      alignItems: \"flex-start\",\n      appearance: \"none\",\n      background: \"none\",\n      border: 0,\n      color: r ? a.gray900 : \"inherit\",\n      cursor: \"pointer\",\n      display: \"inline-flex\",\n      gap: a.spacing2Xs,\n      outline: 0,\n      padding: a.spacingS,\n      \"&:focus\": {\n        backgroundColor: a.gray100,\n        boxShadow: a.glowPrimary\n      },\n      \"&:focus:not(:focus-visible)\": {\n        backgroundColor: \"unset\",\n        boxShadow: \"unset\"\n      },\n      \"&:focus-visible\": {\n        backgroundColor: a.gray100,\n        boxShadow: a.glowPrimary\n      }\n    }),\n    container: css({\n      backgroundColor: a.colorWhite,\n      borderBottom: `1px solid ${a.gray200}`,\n      padding: t ? 0 : a.spacingS,\n      textAlign: e,\n      color: a.gray700,\n      fontWeight: o ? a.fontWeightMedium : a.fontWeightNormal,\n      verticalAlign: l\n    }),\n    sortIcon: p => css({\n      fill: a.gray400,\n      opacity: p ? 1 : 0,\n      transition: `opacity ${a.transitionEasingCubicBezier} ${a.transitionDurationDefault}`\n    })\n  };\n};\nfunction Pe(e) {\n  return isValidElement(e) && Boolean(e.props.children);\n}\nfunction g(e) {\n  let t = \"\";\n  return Children.toArray(e).map(o => {\n    isValidElement(o) && Pe(o) ? t += g(o.props.children) : (typeof o == \"string\" || typeof o == \"number\") && (t = `${t}${o}`);\n  }), t;\n}\nvar X = (o => (o.Ascending = \"ascending\", o.Descending = \"descending\", o))(X || {}),\n  ve = {\n    [\"ascending\"]: SortAscendingIcon,\n    [\"descending\"]: SortDescendingIcon\n  };\nfunction j(m, T) {\n  var b = m,\n    {\n      align: e = \"left\",\n      children: t,\n      className: o,\n      isSortable: r,\n      sortDirection: l,\n      testId: p = \"cf-ui-table-cell\"\n    } = b,\n    i = d(b, [\"align\", \"children\", \"className\", \"isSortable\", \"sortDirection\", \"testId\"]);\n  let [y, x] = useState(!1),\n    {\n      as: Z,\n      name: ee,\n      offsetTop: oe\n    } = M(),\n    {\n      verticalAlign: te\n    } = K(),\n    re = ve[l],\n    S = ee === \"head\",\n    B = _({\n      isSortable: S ? r : void 0,\n      sortDirection: l,\n      isTableHead: S,\n      align: e,\n      verticalAlign: te\n    }),\n    le = S ? Caption : Text,\n    ae = r ? {\n      \"aria-sort\": l != null ? l : \"none\",\n      onBlur: () => x(!1),\n      onFocus: () => x(!0),\n      onMouseEnter: () => x(!0),\n      onMouseLeave: () => x(!1)\n    } : {},\n    ne = useMemo(() => g(t), [t]),\n    L = t;\n  return r && (L = P.createElement(\"button\", {\n    \"aria-label\": `Sort ${l === \"ascending\" ? \"descending\" : \"ascending\"} by ${ne}`,\n    className: B.button,\n    type: \"button\"\n  }, t, l ? P.createElement(re, {\n    size: \"tiny\",\n    variant: \"secondary\"\n  }) : P.createElement(SortIcon, {\n    \"aria-hidden\": !y,\n    className: B.sortIcon(y),\n    size: \"tiny\",\n    variant: \"secondary\"\n  }))), P.createElement(le, s(n(n({}, i), ae), {\n    as: Z,\n    className: cx(B.container, o),\n    ref: T,\n    style: s(n({}, i.style), {\n      top: oe || void 0\n    }),\n    testId: p\n  }), L);\n}\nj.displayName = \"TableCell\";\nvar k = forwardRef(j);\nvar q = () => ({\n  sticky: css({\n    th: {\n      position: \"sticky\",\n      top: 0,\n      zIndex: a.zIndexDefault\n    }\n  })\n});\nvar h = forwardRef((T, i) => {\n  var m = T,\n    {\n      children: e,\n      className: t,\n      isSticky: o = !1,\n      offsetTop: r,\n      testId: l = \"cf-ui-table-head\"\n    } = m,\n    p = d(m, [\"children\", \"className\", \"isSticky\", \"offsetTop\", \"testId\"]);\n  let b = q(),\n    y = cx(o && b.sticky, t);\n  return P.createElement(v, {\n    value: s(n({}, u.head), {\n      offsetTop: r || 0\n    })\n  }, P.createElement(Box, s(n({}, p), {\n    as: \"thead\",\n    className: y,\n    ref: i,\n    testId: l\n  }), e));\n});\nh.displayName = \"TableHead\";\nvar Y = () => ({\n  root: css({\n    \"&:last-child td\": {\n      borderBottom: \"none\"\n    },\n    \"&:hover td\": {\n      backgroundColor: a.gray100\n    }\n  }),\n  selected: css({\n    \"td, th\": {\n      backgroundColor: a.blue100\n    },\n    \"td:last-child\": {\n      boxShadow: `inset -2px 0 0 ${a.blue500}`\n    }\n  })\n});\nvar R = forwardRef((i, p) => {\n  var T = i,\n    {\n      className: e,\n      children: t,\n      isSelected: o = !1,\n      testId: r = \"cf-ui-table-row\"\n    } = T,\n    l = d(T, [\"className\", \"children\", \"isSelected\", \"testId\"]);\n  let m = Y();\n  return P.createElement(Box, s(n({}, l), {\n    as: \"tr\",\n    className: cx(m.root, {\n      [m.selected]: o\n    }, e),\n    ref: p,\n    testId: r\n  }), t);\n});\nR.displayName = \"TableRow\";\nvar f = E;\nf.Row = R;\nf.Head = h;\nf.Cell = k;\nf.Body = H;\nexport { f as Table, H as TableBody, k as TableCell, I as TableCellContext, v as TableCellContextProvider, X as TableCellSorting, h as TableHead, R as TableRow, u as contextOptions, M as useTableCellContext };","map":{"version":3,"names":[],"sources":["/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/Table.tsx","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/Table.styles.ts","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/tableContext.ts","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/TableBody/TableBody.tsx","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/TableCell/TableCell.tsx","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/TableCell/TableCellContext.ts","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/TableCell/TableCell.styles.ts","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/utils/src/getTextFromChildren/getTextFromChildren.ts","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/TableHead/TableHead.tsx","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/TableHead/TableHead.styles.ts","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/TableRow/TableRow.tsx","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/TableRow/TableRow.styles.ts","/Users/gracielaalaniz/Documents/cloudflare-build/node_modules/@contentful/f36-table/src/CompoundTable.tsx"],"sourcesContent":["import { cx } from 'emotion';\nimport React, { forwardRef } from 'react';\nimport {\n  Box,\n  type CommonProps,\n  type PropsWithHTMLElement,\n  type ExpandProps,\n} from '@contentful/f36-core';\nimport type * as CSS from 'csstype';\n\nimport { getTableStyles } from './Table.styles';\nimport { TableContextProvider } from './tableContext';\n\nexport type TableInternalProps = CommonProps & {\n  /**\n   * @default 'inline'\n   */\n  layout?: 'inline' | 'embedded';\n  /**\n   * @default 'top'\n   */\n  verticalAlign?: Extract<\n    CSS.Property.VerticalAlign,\n    'baseline' | 'bottom' | 'middle' | 'top'\n  >;\n};\n\nexport type TableProps = PropsWithHTMLElement<TableInternalProps, 'table'>;\n\nexport const Table = forwardRef<HTMLTableElement, ExpandProps<TableProps>>(\n  (\n    {\n      children,\n      className,\n      layout = 'inline',\n      testId = 'cf-ui-table',\n      verticalAlign = 'top',\n      ...otherProps\n    },\n    forwardedRef,\n  ) => {\n    const styles = getTableStyles();\n\n    return (\n      <Box\n        cellPadding=\"0\"\n        cellSpacing=\"0\"\n        {...otherProps}\n        as=\"table\"\n        display=\"table\"\n        ref={forwardedRef}\n        className={cx(styles.root, styles[layout], className)}\n        testId={testId}\n      >\n        <TableContextProvider value={{ verticalAlign }}>\n          {children}\n        </TableContextProvider>\n      </Box>\n    );\n  },\n);\n\nTable.displayName = 'Table';\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getTableStyles = () => ({\n  inline: css({\n    borderRadius: tokens.borderRadiusMedium,\n    boxShadow: `0 0 0 1px ${tokens.gray200}`,\n    'th:first-child': {\n      borderTopLeftRadius: tokens.borderRadiusMedium,\n    },\n    'th:last-child': {\n      borderTopRightRadius: tokens.borderRadiusMedium,\n    },\n    'tr:last-child td:first-child': {\n      borderBottomLeftRadius: tokens.borderRadiusMedium,\n    },\n    'tr:last-child td:last-child': {\n      borderBottomRightRadius: tokens.borderRadiusMedium,\n    },\n  }),\n  embedded: css({\n    borderBottom: `1px solid ${tokens.gray200}`,\n  }),\n  root: css({\n    width: '100%',\n  }),\n});\n","import { createContext, useContext } from 'react';\nimport { TableProps } from './Table';\n\nexport type TableContext = {\n  verticalAlign?: TableProps['verticalAlign'];\n};\n\nexport const TableContext = createContext<TableContext>({});\n\nexport const useTableContext = () => {\n  const context = useContext(TableContext);\n\n  return context;\n};\n\nexport const TableContextProvider = TableContext.Provider;\n","import React, { forwardRef, type ReactElement } from 'react';\nimport {\n  Box,\n  type CommonProps,\n  type PropsWithHTMLElement,\n  type ExpandProps,\n} from '@contentful/f36-core';\n\nexport type TableBodyInternalProps = CommonProps & {\n  children: ReactElement | ReactElement[];\n};\n\nexport type TableBodyProps = PropsWithHTMLElement<\n  TableBodyInternalProps,\n  'tbody'\n>;\n\nfunction _TableBody(\n  { className, children, testId = 'cf-ui-table-body', ...otherProps },\n  forwardedRef,\n) {\n  return (\n    <Box\n      {...otherProps}\n      as=\"tbody\"\n      className={className}\n      ref={forwardedRef}\n      testId={testId}\n    >\n      {children}\n    </Box>\n  );\n}\n\n_TableBody.displayName = 'TableBody';\n\nexport const TableBody = forwardRef<\n  HTMLTableSectionElement,\n  ExpandProps<TableBodyProps>\n>(_TableBody);\n","import { cx } from 'emotion';\nimport React, { forwardRef, useMemo, useState } from 'react';\nimport {\n  type CommonProps,\n  type PropsWithHTMLElement,\n  type ExpandProps,\n  type PolymorphicComponent,\n} from '@contentful/f36-core';\nimport { Text, Caption, type TextProps } from '@contentful/f36-typography';\nimport {\n  SortAscendingIcon,\n  SortDescendingIcon,\n  SortIcon,\n} from '@contentful/f36-icons';\n\nimport { useTableCellContext } from './TableCellContext';\nimport { getTableCellStyles } from './TableCell.styles';\nimport { useTableContext } from '../tableContext';\nimport { getTextFromChildren } from '@contentful/f36-utils/src';\n\nexport enum TableCellSorting {\n  Ascending = 'ascending',\n  Descending = 'descending',\n}\n\nconst SortingIconMap = {\n  [TableCellSorting.Ascending]: SortAscendingIcon,\n  [TableCellSorting.Descending]: SortDescendingIcon,\n};\n\nexport type TableCellInternalProps = CommonProps & {\n  align?: 'center' | 'left' | 'right';\n  children?: React.ReactNode;\n  isSortable?: boolean;\n  sortDirection?: TableCellSorting;\n  width?: string | number;\n} & Pick<TextProps, 'isTruncated' | 'isWordBreak'>;\n\nexport type TableCellProps = PropsWithHTMLElement<\n  TableCellInternalProps,\n  'th' | 'td'\n>;\n\nfunction _TableCell(\n  {\n    align = 'left',\n    children,\n    className,\n    isSortable,\n    sortDirection,\n    testId = 'cf-ui-table-cell',\n    ...otherProps\n  }: TableCellProps,\n  forwardedRef: React.Ref<any>,\n) {\n  const [showSorting, setShowSorting] = useState(false);\n  const { as, name: context, offsetTop } = useTableCellContext();\n  const { verticalAlign } = useTableContext();\n  const SortingIcon = SortingIconMap[sortDirection];\n  const isTableHead = context === 'head';\n  const styles = getTableCellStyles({\n    isSortable: isTableHead ? isSortable : undefined,\n    sortDirection,\n    isTableHead,\n    align,\n    verticalAlign,\n  });\n  const BaseComponent = isTableHead ? Caption : Text;\n  const sortableProps = isSortable\n    ? {\n        'aria-sort': (sortDirection ?? 'none') as\n          | 'none'\n          | 'ascending'\n          | 'descending'\n          | 'other',\n        onBlur: () => setShowSorting(false),\n        onFocus: () => setShowSorting(true),\n        onMouseEnter: () => setShowSorting(true),\n        onMouseLeave: () => setShowSorting(false),\n      }\n    : {};\n  const columnName = useMemo(() => getTextFromChildren(children), [children]);\n  let tableCellContent = children;\n\n  if (isSortable) {\n    tableCellContent = (\n      <button\n        aria-label={`Sort ${\n          sortDirection === TableCellSorting.Ascending\n            ? TableCellSorting.Descending\n            : TableCellSorting.Ascending\n        } by ${columnName}`}\n        className={styles.button}\n        type=\"button\"\n      >\n        {children}\n        {sortDirection ? (\n          <SortingIcon size=\"tiny\" variant=\"secondary\" />\n        ) : (\n          <SortIcon\n            aria-hidden={!showSorting}\n            className={styles.sortIcon(showSorting)}\n            size=\"tiny\"\n            variant=\"secondary\"\n          />\n        )}\n      </button>\n    );\n  }\n\n  return (\n    <BaseComponent\n      {...otherProps}\n      {...sortableProps}\n      as={as}\n      className={cx(styles.container, className)}\n      ref={forwardedRef}\n      style={{\n        ...otherProps.style,\n        top: offsetTop || undefined,\n      }}\n      testId={testId}\n    >\n      {tableCellContent}\n    </BaseComponent>\n  );\n}\n\n_TableCell.displayName = 'TableCell';\n\nexport const TableCell: PolymorphicComponent<\n  ExpandProps<TableCellInternalProps>,\n  'th' | 'td'\n> = forwardRef(_TableCell);\n","import { createContext, useContext } from 'react';\n\nexport type TableCellContextOption = {\n  name: 'body' | 'head';\n  as: 'td' | 'th';\n  offsetTop: number | string;\n};\n\nexport const contextOptions: {\n  body: TableCellContextOption;\n  head: TableCellContextOption;\n} = {\n  body: { name: 'body', as: 'td', offsetTop: 0 },\n  head: { name: 'head', as: 'th', offsetTop: 0 },\n};\n\nexport const TableCellContext = createContext(contextOptions.body);\n\nexport const useTableCellContext = () => {\n  const context = useContext(TableCellContext);\n\n  return context;\n};\n\nexport const TableCellContextProvider = TableCellContext.Provider;\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\nimport { type TableCellInternalProps } from './TableCell';\nimport { type TableProps } from '../Table';\n\ntype GetTableCellStylesArguments = {\n  align: TableCellInternalProps['align'];\n  isSortable?: TableCellInternalProps['isSortable'];\n  isTableHead: boolean;\n  sortDirection: TableCellInternalProps['sortDirection'];\n  verticalAlign?: TableProps['verticalAlign'];\n};\n\nexport const getTableCellStyles = ({\n  align,\n  isSortable,\n  isTableHead,\n  sortDirection,\n  verticalAlign,\n}: GetTableCellStylesArguments) => ({\n  button: css({\n    alignItems: 'flex-start',\n    appearance: 'none',\n    background: 'none',\n    border: 0,\n    color: sortDirection ? tokens.gray900 : 'inherit',\n    cursor: 'pointer',\n    display: 'inline-flex',\n    gap: tokens.spacing2Xs,\n    outline: 0,\n    padding: tokens.spacingS,\n\n    '&:focus': {\n      backgroundColor: tokens.gray100,\n      boxShadow: tokens.glowPrimary,\n    },\n    '&:focus:not(:focus-visible)': {\n      backgroundColor: 'unset',\n      boxShadow: 'unset',\n    },\n    '&:focus-visible': {\n      backgroundColor: tokens.gray100,\n      boxShadow: tokens.glowPrimary,\n    },\n  }),\n  container: css({\n    backgroundColor: tokens.colorWhite,\n    borderBottom: `1px solid ${tokens.gray200}`,\n    padding: isSortable ? 0 : tokens.spacingS,\n    textAlign: align,\n    color: tokens.gray700,\n    fontWeight: isTableHead ? tokens.fontWeightMedium : tokens.fontWeightNormal,\n    verticalAlign,\n  }),\n  sortIcon: (showSorting: boolean) =>\n    css({\n      fill: tokens.gray400,\n      opacity: showSorting ? 1 : 0,\n      transition: `opacity ${tokens.transitionEasingCubicBezier} ${tokens.transitionDurationDefault}`,\n    }),\n});\n","import {\n  Children,\n  isValidElement,\n  type ReactElement,\n  type ReactNode,\n} from 'react';\n\nfunction hasChildren(\n  element: ReactNode,\n): element is ReactElement<{ children: ReactNode | ReactNode[] }> {\n  return isValidElement(element) && Boolean(element.props.children);\n}\n\n/**\n * Recursively extracts text and numbers from React children to return as a\n * combined string.\n *\n * @param children - React node to extract text from\n * @returns String with all child nodes' text combined\n */\nexport function getTextFromChildren(children: ReactNode) {\n  let string = '';\n\n  Children.toArray(children).map((child) => {\n    if (isValidElement(child) && hasChildren(child)) {\n      string += getTextFromChildren(child.props.children);\n    } else if (typeof child === 'string' || typeof child === 'number') {\n      string = `${string}${child}`;\n    }\n  });\n\n  return string;\n}\n","import { cx } from 'emotion';\nimport React, { forwardRef } from 'react';\nimport {\n  Box,\n  type CommonProps,\n  type PropsWithHTMLElement,\n  type ExpandProps,\n} from '@contentful/f36-core';\n\nimport {\n  TableCellContextProvider,\n  contextOptions,\n} from '../TableCell/TableCellContext';\nimport { getTableHeadStyles } from './TableHead.styles';\n\nexport type TableHeadInternalProps = CommonProps & {\n  isSticky?: boolean;\n  offsetTop?: number | string;\n  children: React.ReactNode;\n};\n\nexport type TableHeadProps = PropsWithHTMLElement<\n  TableHeadInternalProps,\n  'thead'\n>;\n\nexport const TableHead = forwardRef<\n  HTMLTableSectionElement,\n  ExpandProps<TableHeadProps>\n>(\n  (\n    {\n      children,\n      className,\n      isSticky = false,\n      offsetTop,\n      testId = 'cf-ui-table-head',\n      ...otherProps\n    },\n    forwardedRef,\n  ) => {\n    const styles = getTableHeadStyles();\n    const classNames = cx(isSticky && styles.sticky, className);\n\n    return (\n      <TableCellContextProvider\n        value={{ ...contextOptions.head, offsetTop: offsetTop || 0 }}\n      >\n        <Box\n          {...otherProps}\n          as=\"thead\"\n          className={classNames}\n          ref={forwardedRef}\n          testId={testId}\n        >\n          {children}\n        </Box>\n      </TableCellContextProvider>\n    );\n  },\n);\n\nTableHead.displayName = 'TableHead';\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getTableHeadStyles = () => ({\n  sticky: css({\n    th: {\n      position: 'sticky',\n      top: 0,\n      zIndex: tokens.zIndexDefault,\n    },\n  }),\n});\n","import { cx } from 'emotion';\nimport React, { forwardRef } from 'react';\nimport {\n  Box,\n  type CommonProps,\n  type PropsWithHTMLElement,\n  type ExpandProps,\n} from '@contentful/f36-core';\nimport { getTableRowStyles } from './TableRow.styles';\n\nexport type TableRowInternalProps = CommonProps & {\n  isSelected?: boolean;\n  children: React.ReactNode;\n};\n\nexport type TableRowProps = PropsWithHTMLElement<TableRowInternalProps, 'tr'>;\n\nexport const TableRow = forwardRef<\n  HTMLTableRowElement,\n  ExpandProps<TableRowProps>\n>(\n  (\n    {\n      className,\n      children,\n      isSelected = false,\n      testId = 'cf-ui-table-row',\n      ...otherProps\n    },\n    forwardedRef,\n  ) => {\n    const styles = getTableRowStyles();\n\n    return (\n      <Box\n        {...otherProps}\n        as=\"tr\"\n        className={cx(\n          styles.root,\n          {\n            [styles.selected]: isSelected,\n          },\n          className,\n        )}\n        ref={forwardedRef}\n        testId={testId}\n      >\n        {children}\n      </Box>\n    );\n  },\n);\n\nTableRow.displayName = 'TableRow';\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getTableRowStyles = () => ({\n  root: css({\n    '&:last-child td': {\n      borderBottom: 'none',\n    },\n    '&:hover td': {\n      backgroundColor: tokens.gray100,\n    },\n  }),\n  selected: css({\n    'td, th': {\n      backgroundColor: tokens.blue100,\n    },\n    'td:last-child': {\n      boxShadow: `inset -2px 0 0 ${tokens.blue500}`,\n    },\n  }),\n});\n","import { Table as OriginalTable } from './Table';\nimport { TableBody } from './TableBody/TableBody';\nimport { TableCell } from './TableCell/TableCell';\nimport { TableHead } from './TableHead/TableHead';\nimport { TableRow } from './TableRow/TableRow';\n\ntype CompoundTable = typeof OriginalTable & {\n  Row: typeof TableRow;\n  Head: typeof TableHead;\n  Cell: typeof TableCell;\n  Body: typeof TableBody;\n};\n\nexport const Table = OriginalTable as CompoundTable;\nTable.Row = TableRow;\nTable.Head = TableHead;\nTable.Cell = TableCell;\nTable.Body = TableBody;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}